{"version":3,"file":"main-b396dc5f.js","sources":["../../../../../../../../https:/deno.land/x/dext@0.10.1/src/runtime/router/matcher.ts","../../../../../../../../https:/deno.land/x/dext@0.10.1/src/runtime/router/router.ts","../../../../../../../../https:/deno.land/x/dext@0.10.1/src/runtime/router/location.ts","../../../../../../../../https:/deno.land/x/dext@0.10.1/src/runtime/mod.tsx","../../../../../../../../https:/deno.land/x/dext@0.10.1/src/runtime/router/interceptor.ts","../../../../../../../../https:/deno.land/x/dext@0.10.1/src/runtime/memo.js","../../../../../../../../dext:/main.js","../../../../../../../../https:/deno.land/x/dext@0.10.1/src/runtime/default_app.tsx"],"sourcesContent":["export function makeMatcher() {\n  const cache: Record<\n    string,\n    {\n      keys: { name: string; repeat: boolean }[];\n      regexp: RegExp;\n    }\n  > = {};\n\n  // obtains a cached regexp version of the pattern\n  const getRegexp = (pattern: string) =>\n    cache[pattern] || (cache[pattern] = pathToRegexp(pattern));\n\n  return (\n    pattern: string,\n    path: string,\n  ): [boolean, Record<string, string | string[]> | null] => {\n    const { regexp, keys } = getRegexp(pattern || \"\");\n    const out = regexp.exec(path);\n\n    if (!out) return [false, null];\n\n    // formats an object with matched params\n    const params = keys.reduce<Record<string, string | string[]>>(\n      (params, key, i) => {\n        params[key.name] = key.repeat\n          ? out[i + 1] ? out[i + 1].split(\"/\") : []\n          : out[i + 1];\n        return params;\n      },\n      {},\n    );\n\n    return [true, params];\n  };\n}\n\n// escapes a regexp string (borrowed from path-to-regexp sources)\n// https://github.com/pillarjs/path-to-regexp/blob/v3.0.0/index.js#L202\nconst escapeRx = (str: string) =>\n  str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n\n// returns a segment representation in RegExp based on flags\n// adapted and simplified version from path-to-regexp sources\nconst rxForSegment = (repeat: boolean, optional: boolean, prefix: number) => {\n  let capture = repeat ? \"((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*)\" : \"([^\\\\/]+?)\";\n  if (optional && prefix) capture = \"(?:\\\\/\" + capture + \")\";\n  return capture + (optional ? \"?\" : \"\");\n};\n\nconst pathToRegexp = (pattern: string) => {\n  const groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g;\n\n  let match = null,\n    lastIndex = 0,\n    result = \"\";\n  const keys = [];\n\n  while ((match = groupRx.exec(pattern)) !== null) {\n    const [_, segment, mod] = match;\n\n    // :foo  [1]      (  )\n    // :foo? [0 - 1]  ( o)\n    // :foo+ [1 - ∞]  (r )\n    // :foo* [0 - ∞]  (ro)\n    const repeat = mod === \"+\" || mod === \"*\";\n    const optional = mod === \"?\" || mod === \"*\";\n    const prefix = optional && pattern[match.index - 1] === \"/\" ? 1 : 0;\n\n    const prev = pattern.substring(lastIndex, match.index - prefix);\n\n    keys.push({ name: segment, repeat });\n    lastIndex = groupRx.lastIndex;\n\n    result += escapeRx(prev) + rxForSegment(repeat, optional, prefix);\n  }\n\n  result += escapeRx(pattern.substring(lastIndex));\n  return { keys, regexp: new RegExp(\"^\" + result + \"(?:\\\\/)?$\", \"i\") };\n};\n","import { makeMatcher } from \"./matcher.ts\";\n\nexport type Route<T> = [route: string, data: T];\n\nexport class Router<T> {\n  private matcher = makeMatcher();\n\n  constructor(private routes: Route<T>[]) {}\n\n  getRoute(path: string):\n    | [Route<T>, Record<string, string | string[]>]\n    | [null, Record<string, string | string[]>] {\n    for (const route of this.routes) {\n      const [match, data] = this.matcher(route[0], path);\n      if (match) return [route, data!];\n    }\n    return [null, {}];\n  }\n}\n","import { createContext } from \"../../../deps/preact/mod.ts\";\nimport { useContext } from \"../../../deps/preact/hooks.ts\";\n\nexport const locationCtx = createContext<[string, (to: string) => void]>(\n  [\"\", () => {}],\n);\n\nexport function useLocation(): readonly [string, (to: string) => void] {\n  // @ts-expect-error because this is a hidden variable.\n  if (window.__DEXT_SSR) {\n    return [window.location.pathname, (_to: string) => {\n      throw new TypeError(\"Can not navigate in SSR context.\");\n    }];\n  }\n  return useContext(locationCtx);\n}\n","import { h, hydrate } from \"../../deps/preact/mod.ts\";\nimport type { ComponentType } from \"../../deps/preact/mod.ts\";\nimport {\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from \"../../deps/preact/hooks.ts\";\nimport type { AppProps, PageProps } from \"./type.ts\";\nimport { Router } from \"./router/router.ts\";\nimport { initRouter } from \"./router/interceptor.ts\";\nimport { locationCtx } from \"./router/location.ts\";\nimport { memo } from \"./memo.js\";\n\ntype Route = [route: string, data: RouteData];\ntype RouteData = [\n  component: () => Promise<{ default: ComponentType<PageProps> }>,\n  hasStaticData: boolean,\n];\n\nexport async function start(routes: Route[], app: ComponentType<AppProps>) {\n  const router = new Router<RouteData>(routes);\n  const path = window.location.pathname;\n  const [route] = router.getRoute(path);\n  if (!route) throw new Error(\"Failed to match inital route.\");\n\n  const initialPage = await loadComponent(route[1][0](), route[1][1], path);\n\n  hydrate(\n    <Dext router={router} app={app} initialPage={initialPage} />,\n    window.document.getElementById(\"__dext\")!,\n  );\n}\n\ntype PageComponent = ComponentType<{\n  route: Record<string, string | string[]>;\n}>;\n\nfunction Dext(props: {\n  router: Router<RouteData>;\n  app: ComponentType<AppProps>;\n  initialPage: PageComponent;\n}) {\n  const [desiredPath, setDesiredPath] = useState(window.location.pathname);\n  const [desiredRoute, desiredMatch] = useMemo(\n    () => props.router.getRoute(desiredPath),\n    [props.router, desiredPath],\n  );\n\n  const navigate = useCallback(\n    (to: string) => {\n      window.history.pushState(null, \"\", to);\n      setDesiredPath(to);\n    },\n    [setDesiredPath],\n  );\n\n  useEffect(() => {\n    // sets up event listeners on <a> elements\n    initRouter(props.router, navigate);\n\n    window.addEventListener(\"popstate\", (event) => {\n      setDesiredPath(window.location.pathname);\n    });\n  }, [props.router, navigate]);\n\n  const [page, setPage] = useState<\n    [PageComponent | null, string, Record<string, string | string[]>]\n  >([props.initialPage, desiredPath, desiredMatch]);\n\n  useEffect(() => {\n    let cancelled = false;\n    if (desiredRoute) {\n      loadComponent(desiredRoute[1][0](), desiredRoute[1][1], desiredPath)\n        .then((page) => {\n          if (!cancelled) {\n            setPage([page, desiredPath, desiredMatch]);\n          }\n        })\n        .catch((err) => {\n          if (!cancelled) {\n            console.error(err);\n            window.location.pathname = desiredPath;\n          }\n        });\n    } else {\n      setPage([null, desiredPath, desiredMatch]);\n    }\n    () => (cancelled = true);\n  }, [desiredRoute, desiredPath, desiredMatch]);\n\n  return <DextPage App={props.app} page={page} navigate={navigate} />;\n}\n\nconst DextPage = memo(\n  (props: {\n    App: ComponentType<AppProps>;\n    page: [PageComponent | null, string, Record<string, string | string[]>];\n    navigate: (to: string) => void;\n  }) => {\n    const { App, page, navigate } = props;\n    const [Page, path, match] = page;\n    return (\n      <locationCtx.Provider value={[path, navigate]}>\n        <div>\n          <App>{Page === null ? <Error404 /> : <Page route={match!} />}</App>\n        </div>\n      </locationCtx.Provider>\n    );\n  },\n);\n\nasync function loadComponent(\n  componentPromise: Promise<{ default: ComponentType<PageProps> }>,\n  hasStaticData: boolean,\n  path: string,\n): Promise<PageComponent> {\n  const [Component, data]: [\n    ComponentType<PageProps>,\n    unknown,\n  ] = await Promise.all([\n    componentPromise.then((m) => m.default),\n    (async () => {\n      if (hasStaticData) {\n        const req = await fetch(`/_dext/${path.slice(1) || \"index\"}.json`, {\n          headers: { accepts: \"application/json\" },\n        });\n        if (req.status === 404) return undefined;\n        return req.json();\n      }\n      return undefined;\n    })(),\n  ]);\n  return (props: { route: Record<string, string | string[]> }) => {\n    if (hasStaticData && data === undefined) return <Error404 />;\n    return <Component route={props.route} data={data} />;\n  };\n}\n\nfunction Error404() {\n  return <div>404 not found</div>;\n}\n","import type { Router } from \"./router.ts\";\n\nexport function initRouter(\n  router: Router<unknown>,\n  navigate: (to: string) => void,\n) {\n  function routeFromLink(node: HTMLAnchorElement) {\n    // only valid elements\n    if (!node || !node.getAttribute) return;\n\n    const href = node.getAttribute(\"href\"),\n      target = node.getAttribute(\"target\");\n\n    // ignore links with targets and non-path URLs\n    if (\n      !href ||\n      !href.match(/^\\//g) ||\n      (target && !target.match(/^_?self$/i))\n    ) {\n      return;\n    }\n\n    const [route] = router.getRoute(href);\n    if (route) {\n      navigate(href);\n      return true;\n    }\n\n    return false;\n  }\n\n  addEventListener(\"click\", (e: MouseEvent) => {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button !== 0) {\n      return;\n    }\n\n    let t = e.target as HTMLAnchorElement;\n\n    do {\n      if (String(t.nodeName).toUpperCase() === \"A\" && t.getAttribute(\"href\")) {\n        if (t.hasAttribute(\"native\")) return;\n        // if link is handled by the router, prevent browser defaults\n        if (routeFromLink(t)) {\n          if (e.stopImmediatePropagation) e.stopImmediatePropagation();\n          if (e.stopPropagation) e.stopPropagation();\n          e.preventDefault();\n          return;\n        }\n      }\n    } while ((t = t.parentNode as HTMLAnchorElement));\n  });\n}\n","/// <reference types=\"./memo.d.ts\" />\n\nimport { createElement } from \"../../deps/preact/mod.ts\";\n\nexport function shallowDiffers(a, b) {\n  for (const i in a) if (i !== \"__source\" && !(i in b)) return true;\n  for (const i in b) if (i !== \"__source\" && a[i] !== b[i]) return true;\n  return false;\n}\n\nexport function memo(c, comparer) {\n  function shouldUpdate(nextProps) {\n    const ref = this.props.ref;\n    const updateRef = ref == nextProps.ref;\n    if (!updateRef && ref) {\n      ref.call ? ref(null) : (ref.current = null);\n    }\n\n    if (!comparer) {\n      return shallowDiffers(this.props, nextProps);\n    }\n\n    return !comparer(this.props, nextProps) || !updateRef;\n  }\n\n  function Memoed(props) {\n    this.shouldComponentUpdate = shouldUpdate;\n    return createElement(c, props);\n  }\n  Memoed.displayName = \"Memo(\" + (c.displayName || c.name) + \")\";\n  Memoed.prototype.isReactComponent = true;\n  Memoed._forwarded = true;\n  return Memoed;\n}\n","\n        import { start } from \"https://deno.land/x/dext@0.10.1/src/runtime/mod.tsx\";\nimport App from \"https://deno.land/x/dext@0.10.1/src/runtime/default_app.tsx\";\n\n\nstart([[\"/\", [() => import(\"dext-page:///home/runner/work/akeo.me/akeo.me/pages/index.tsx\"), false]]], App);","import type { AppProps } from \"./type.ts\";\n\nfunction App(props: AppProps) {\n  return props.children;\n}\n\nexport default App;\n"],"names":["makeMatcher","cache","pattern","path","regexp","keys","pathToRegexp","getRegexp","out","exec","reduce","params","key","i","name","repeat","split","escapeRx","str","replace","rxForSegment","optional","prefix","capture","groupRx","match","lastIndex","result","_","segment","mod","index","prev","substring","push","RegExp","Router","routes","route","data","matcher","locationCtx","createContext","Dext","props","desiredPath","setDesiredPath","useState","window","location","pathname","desiredRoute","desiredMatch","useMemo","router","getRoute","navigate","useCallback","to","history","pushState","routeFromLink","node","getAttribute","href","target","e","ctrlKey","metaKey","altKey","shiftKey","button","t","String","nodeName","toUpperCase","hasAttribute","stopImmediatePropagation","stopPropagation","preventDefault","parentNode","addEventListener","event","page","setPage","initialPage","then","catch","err","error","DextPage","app","c","comparer","shouldUpdate","nextProps","ref","updateRef","call","current","a","b","shallowDiffers","Memoed","shouldComponentUpdate","createElement","displayName","prototype","isReactComponent","_forwarded","memo","App","Page","Provider","Error404","loadComponent","componentPromise","hasStaticData","Component","Promise","all","m","default","req","fetch","slice","status","json","undefined","Error","document","getElementById","start","import","children"],"mappings":"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"}